---
layout: post
title: "[Bandit] Level 20 → Level 21"
date: 2025-07-05 09:01:00 +0900
categories: [bandit]
tags: [overthewire, bandit, linux, netcat, setuid]
---

## 1. 문제 개요

> **Level Goal**
> 
> There is a **setuid binary** in the home directory that does the following: it makes a connection to localhost on a port you specify as a commandline argument. It then reads a line of text from the connection and compares it to the password in the previous level (bandit20). If the password is correct, it will transmit the password for the next level (bandit21).

홈 디렉토리에 있는 `suconnect`라는 프로그램은 우리가 지정한 포트로 접속을 시도합니다. 이 프로그램에게 "접속할 곳"을 만들어주고, 그곳에서 현재(Level 20) 비밀번호를 보내주면, 프로그램이 맞는지 확인하고 다음 레벨 비밀번호를 돌려주는 방식입니다. 즉, 우리가 **서버 역할**을 해야 했습니다.

---

## 2. 사용 명령어

| 명령어 | 설명 |
|--------|------|
| `nc -l -p [포트]` | Netcat을 **Listen 모드(서버)** 로 실행하여 특정 포트에서 연결을 기다림 |
| `&` | 명령어를 백그라운드에서 실행 |
| `jobs` / `fg` | 백그라운드 작업 확인 / 포그라운드로 가져오기 |

---

## 3. 풀이 과정

이전 레벨에서 얻은 비밀번호로 `bandit20`에 접속합니다.

```bash
ssh bandit20@bandit.labs.overthewire.org -p 2220
```

### 1. 상황 파악
`suconnect` 파일은 SetUID가 걸려있어 `bandit21` 등의 권한으로 실행될 것입니다.
- 우리는 포트를 열고 기다려야 합니다. (Netcat Listen)
- 동시에 `suconnect`를 실행해서 우리 포트로 접속하게 시켜야 합니다.

### 2. 해결 전략: 백그라운드 실행
터미널을 2개 띄우는 방법도 있지만, 여기서는 **백그라운드 실행(`&`)** 기능을 이용해 하나의 터미널에서 해결해 보겠습니다.

### 3. 포트 리스닝 (서버 구동)
`nc`로 로컬 포트(예: 8888)를 엽니다. `-l`(Listen) 옵션을 사용합니다. `&`를 붙여서 백그라운드에서 실행되게 합니다. (안 그러면 여기서 멈춰있습니다)

```bash
bandit20@bandit:~$ nc -l -p 8888 &
[1] 12345
```

### 4. 접속 시도 및 비밀번호 전송
이제 `suconnect`를 실행해서 방금 연 8888번 포트로 접속하게 합니다.

```bash
bandit20@bandit:~$ ./suconnect 8888
Read: GbKksEFF4yrVs6il55v6gwY5aVje5f0j
Password matches, sending next password
gE269g2h3mw3pwgrq0Lh6aMo31dYVI_9
```

실제로는 연결만 되고 아무 일도 안 일어날 수 있습니다. `suconnect`는 접속 후 **입력을 기다리기 때문**입니다. 따라서 연결된 세션에 현재 비밀번호를 직접 타이핑해 넣거나, 아래처럼 미리 입력을 준비해야 원활하게 동작합니다.

**더 확실한 풀이 (자동화)**
현재 비밀번호를 `nc`에 미리 입력해두고 대기시킵니다.

```bash
echo "GbKksEFF4yrVs6il55v6gwY5aVje5f0j" | nc -l -p 8888 &
./suconnect 8888
```

1. `echo ... | nc ...`: 현재 비밀번호를 `nc`의 입력으로 넣어줍니다. `nc`는 연결되자마자 이 비밀번호를 상대방(`suconnect`)에게 보냅니다.
2. `./suconnect 8888`: 프로그램이 8888포트로 접속하여 비밀번호를 받고, 맞으면 다음 비밀번호를 출력합니다.

---

## 4. 결과

<details markdown="1">
<summary>비밀번호 확인</summary>

```
gE269g2h3mw3pwgrq0Lh6aMo31dYVI_9
```

</details>

---

## 5. 배운 점

1. **서버-클라이언트 구조**: 보통은 우리가 클라이언트가 되어 서버에 접속하지만, 이번엔 직접 포트를 열고 서버 역할을 해보았습니다.
2. **백그라운드 실행 (`&`)**: 리눅스 터미널 하나에서 동시에 여러 작업을 하기 위해 필수적인 기능입니다.

---

## 6. 보안 관점

- **Reverse Shell (리버스 쉘)**: 해커가 방화벽을 우회하기 위해 사용하는 기법과 유사합니다. 방화벽은 보통 외부에서 내부로 들어오는 연결(Inbound)은 막지만, 내부에서 외부로 나가는 연결(Outbound)은 허용하는 경우가 많습니다. 해커는 자기 컴퓨터에 포트를 열어두고(`nc -l`), 감염된 서버에서 해커 컴퓨터로 접속(`nc 해커IP`)하게 하여 쉘을 획득합니다. 이 문제의 `suconnect`가 바로 그런 "내부에서 연결을 시도하는" 역할을 수행했습니다.

<hr class="short-rule">