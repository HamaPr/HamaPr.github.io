---
layout: post
title: "[Bandit] Level 32 → Level 33"
date: 2025-07-19 09:03:00 +0900
categories: [bandit]
tags: [overthewire, bandit, linux, shell, uppercase]
---

## 1. 문제 개요

> **Level Goal**
> 
> After logging in to the machine, you will find a shell that is running with a very limited command set.

로그인하면 일반적인 프롬프트(`$`, `#`)가 아니라 이상한 껍데기(Shell)에 갇히게 되었습니다. 이 쉘은 **입력하는 모든 글자를 대문자로 바꿔버렸습니다.** 리눅스는 대소문자를 엄격하게 구분하므로, `ls`를 `LS`로 바꾸면 "그런 명령은 없다"며 아무것도 할 수 없었습니다.

---

## 2. 사용 명령어

| 명령어 | 설명 |
|--------|------|
| `$0` | 현재 실행 중인 프로그램(쉘)의 이름을 담고 있는 특수 변수 |
| `/bin/sh` 또는 `/bin/bash` | 리눅스의 표준 쉘 프로그램 |

---

## 3. 풀이 과정

`bandit32` 계정으로 로그인합니다.

```bash
ssh bandit32@bandit.labs.overthewire.org -p 2220
```

### 1. 상황 파악
접속하자마자 이상한 쉘이 뜹니다.

```bash
WELCOME TO THE UPPERCASE SHELL
>> ls
sh: LS: command not found
>> whoami
sh: WHOAMI: command not found
```
소문자로 쳐도 다 대문자로 바뀌어서 실행되니 아무것도 안 먹힙니다.

### 2. 해결 전략
명령어 이름이 아니라 **파일 이름이나 변수값**으로 우회할 수 있는지 고민했습니다.
리눅스 쉘에는 `$0`이라는 특별한 변수가 있습니다. 이는 "지금 실행된 나 자신(프로그램명)"을 가리킵니다.
만약 `$0`이라고 입력하면 변수 이름(`0`)은 숫자라 대소문자 구분이 없으므로 통과될 것이라 판단했습니다.

### 3. 실습 진행
```bash
>> $0
$ 
```
`$0`을 입력하니 쉘이 입력을 받아서 "현재 실행 중인 쉘(`sh` 또는 `bash`)"을 다시 실행시켰습니다.
입력이 대문자로 바뀌기 전에 변수 확장(`$0` -> `bash`)이 먼저 일어나고, 그 결과인 `bash` (소문자)가 실행되면서 **새로운 자식 쉘**이 뜬 것입니다! 이 쉘은 부모 프로세스(Upper Shell)의 제약을 받지 않는 자유로운 상태입니다.

### 4. 비밀번호 획득
이제 정상적인 쉘입니다.

```bash
$ whoami
bandit33
$ cat /etc/bandit_pass/bandit33
56l9...
```

---

## 4. 결과

<details markdown="1">
<summary>비밀번호 확인</summary>

```
c9c31...
```

</details>

---

## 5. 배운 점

1. **매개변수 확장 (Parameter Expansion)**: 쉘은 명령어를 실행하기 전에 변수(`$VAR`)를 먼저 실제 값으로 바꿉니다. 이 순서를 이용하면 필터링을 우회할 수 있습니다.
2. **$0의 의미**: 스크립트나 프로그램 내부에서 자기 자신의 이름을 알아낼 때 사용하는 변수입니다.

---

## 6. 보안 관점

- **입력 값 검증의 허점**: 단순히 대문자로 바꾸는 것(`toupper`)만으로는 보안이 되지 않습니다. 해커는 언제나 입력값이 변환되기 전의 처리 단계(Parsing)나, 대소문자 구분이 없는 요소(특수문자, 숫자)를 찾아서 파고듭니다.

<hr class="short-rule">