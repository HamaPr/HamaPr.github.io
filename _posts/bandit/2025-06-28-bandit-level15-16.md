---
layout: post
title: "[Bandit] Level 15 → Level 16"
date: 2025-06-28 09:01:00 +0900
categories: [bandit]
tags: [overthewire, bandit, linux, openssl, s_client, mitm]
---

## 1. 문제 개요

> **Level Goal**
> 
> The password for the next level can be retrieved by submitting the password of the current level to **port 30001 on localhost using SSL encryption**.

이전 레벨(`nc`)과 비슷하지만, 이번에는 **SSL(Secure Sockets Layer)** 암호화를 사용해야 했습니다. `nc`는 기본적으로 암호화를 지원하지 않으므로(`ncat` 제외), `openssl` 도구를 사용해야 했습니다.

---

## 2. 사용 명령어

| 명령어 | 설명 |
|--------|------|
| `openssl` | SSL/TLS 관련 다양한 작업을 수행하는 만능 도구 (인증서 생성, 암호화 통신 등) |
| `s_client` | SSL/TLS 클라이언트 기능을 수행하는 하위 명령어 |
| `-connect [호스트]:[포트]` | 지정한 호스트와 포트에 SSL 연결을 시도 |

---

## 3. 풀이 과정

`bandit15` 계정으로 로그인합니다.

```bash
ssh bandit15@bandit.labs.overthewire.org -p 2220
```

### 1. 현재 레벨 비밀번호 확인 및 포트 확인

먼저 현재 레벨(`bandit15`)의 비밀번호를 확인합니다.

```bash
bandit15@bandit:~$ cat /etc/bandit_pass/bandit15
BfMYroe26WYalil77FoDi9qh59bKceII
```

`bandit15`의 홈 디렉토리에는 아무것도 없습니다. 이번엔 파일이 아니라 **포트** 어딘가에 정답을 주는 서버가 숨어있습니다. `localhost`의 30001 포트라고 문제에서 알려줬지만, 확인차 `nmap`을 써봅니다.

```bash
bandit15@bandit:~$ nmap -p 30001 localhost
Starting Nmap 7.80 ( https://nmap.org ) at 2024-07-29 10:00 KST
Nmap scan report for localhost (127.0.0.1)
Host is up (0.0000080s latency).

PORT      STATE SERVICE
30001/tcp open  unknown

Nmap done: 1 IP address (1 host up) scanned in 0.04 seconds
```
30001 포트가 열려있음을 확인했습니다.

### 2. 접속 시도 (OpenSSL)
이전 레벨(`nc`)과는 다르게 SSL 암호화를 사용하므로 `openssl s_client`를 사용해야 합니다.
`IGNITE`(접속) 명령으로 `localhost:30001`에 연결합니다.

```bash
bandit15@bandit:~$ openssl s_client -connect localhost:30001
```

명령어를 실행하면 서버의 인증서 정보가 주르륵 출력되고, 마지막에 `Verify return code: ...` 등이 나오며 입력을 대기합니다.
```
...
depth=0 CN = localhost
verify error:num=18:self signed certificate
verify return:1
depth=0 CN = localhost
verify return:1
```

### 3. 비밀번호 제출
연결에 성공하면 화면이 깜빡이며 대기 상태가 됩니다. 이때 현재 레벨(`bandit15`)의 비밀번호를 입력하면, 서버가 정답(`bandit16` 비밀번호)을 보내줍니다.

```
...
Verify return code: 18 (self signed certificate)
---
BfMYroe26WYalil77FoDi9qh59bKceII  <-- 입력 후 엔터
Correct!
cluFn7w7tm7d0LgFAEnvhDBpQh2f3KAn
```

`Correct!` 메시지와 함께 다음 레벨 비밀번호가 출력됩니다.

### 심화: `-quiet` 옵션 사용
인증서 정보 같은 잡다한 출력을 보지 않고 깔끔하게 연결하고 싶다면 `-quiet` 옵션을 사용하면 됩니다.

```bash
bandit15@bandit:~$ openssl s_client -quiet -connect localhost:30001
depth=0 CN = localhost
verify error:num=18:self signed certificate
verify return:1
depth=0 CN = localhost
verify return:1
BfMYroe26WYalil77FoDi9qh59bKceII
Correct!
cluFn...
```

---

## 4. 결과

<details markdown="1">
<summary>비밀번호 확인</summary>

```
cluFn7w7tm7d0LgFAEnvhDBpQh2f3KAn
```

</details>

---

## 5. 배운 점

1. **SSL/TLS 통신의 필요성**: 이전 레벨의 평문 통신과 달리, SSL을 사용하면 데이터가 암호화되어 전송되므로 중간에 누가 패킷을 가로채더라도 내용을 알 수 없습니다.
2. **`openssl` 도구 활용**: 웹 서버(HTTPS)나 메일 서버 등 SSL을 사용하는 서비스의 상태를 점검하거나 디버깅할 때 `openssl s_client`가 매우 유용하게 쓰입니다.

---

## 6. 보안 관점

- **MITM (Man-In-The-Middle) 공격**: 해커가 공유기나 통신 회선 중간에 끼어들어 데이터를 훔쳐보는 공격입니다. 암호화되지 않은 HTTP나 Telnet을 쓰면 비밀번호가 그대로 노출됩니다.
- **인증서 (Certificate)**: 접속할 때 서버가 제시한 인증서는 "내가 진짜 네이버/구글이 맞다"는 신분증입니다. 브라우저는 이 인증서가 신뢰할 수 있는 기관(CA)에서 발급된 것인지 검사하여 가짜 사이트(피싱)를 걸러냅니다. (이 문제에서는 사설 인증서라 `verify error`가 뜬 것입니다.)

<hr class="short-rule">