---
layout: post
title: "[Bandit] Level 16 → Level 17"
date: 2025-06-28 09:02:00 +0900
categories: [bandit]
tags: [overthewire, bandit, linux, nmap, openssl, private-key]
---

## 1. 문제 개요

> **Level Goal**
> 
> The credentials for the next level can be retrieved by submitting the password of the current level to **a port on localhost in the range 31000 to 32000**.
> 
> Which port is it?
> First find out which of these ports have a server listening on them. Then find out which of those speak **SSL** and which don't. There is only one server that will give the next credentials, the others will just send back whatever you send to it.

범인 찾기 문제였습니다. 31000~32000번 사이에는 여러 포트가 열려있지만, 목표는 **SSL을 사용하고** + **올바른 응답을 주는** 단 하나의 포트였습니다. 이를 찾기 위해 **포트 스캐닝(Port Scanning)** 기술이 필요했습니다.

---

## 2. 사용 명령어

| 명령어 | 설명 |
|--------|------|
| `nmap [옵션] [타겟]` | 네트워크 스캐닝 도구. 열린 포트, 실행 중인 서비스, OS 정보 등을 파악 |
| `-p [범위]` | 스캔할 포트 범위를 지정 (예: `-p 31000-32000`) |
| `-sV` | 열린 포트에서 실행 중인 **서비스 버전**을 탐지 (SSL 여부 확인 가능) |

---

## 3. 풀이 과정

`bandit16` 계정으로 로그인합니다.

```bash
ssh bandit16@bandit.labs.overthewire.org -p 2220
```

### 1. 포트 스캔 (nmap)
31000번~32000번 사이 중 하나라고 했으니, 이 범위를 스캔해서 열려있는 포트를 찾습니다.

```bash
bandit16@bandit:~$ nmap -p 31000-32000 localhost

PORT      STATE SERVICE
31046/tcp open  unknown
31518/tcp open  unknown
31691/tcp open  unknown
31790/tcp open  unknown
31960/tcp open  unknown
```
5개의 포트가 열려 있습니다. 이 중에서 SSL을 쓰는 녀석을 찾아야 합니다.

### 2. 서비스 판별
열린 포트가 5개나 있습니다. 문제 조건은 "SSL을 사용하고", "다른 말(Echo)은 안 하고 정답만 주는" 서버입니다.
`nmap -sV` 옵션을 줘서 각 포트가 무슨 서비스를 하는지 자세히 봅니다.
```bash
bandit16@bandit:~$ nmap -p 31000-32000 -sV localhost
...
31046/tcp open  echo
31518/tcp open  echo
31691/tcp open  echo
31790/tcp open  ssl/unknown  <-- SSL 발견!
31960/tcp open  echo
```
분석 결과:
- 31046, 31518, 31691: `echo` 서비스 (내가 보낸 말을 그대로 따라함) - 탈락
- 31960: `echo` 서비스 - 탈락
- **31790**: `ssl/unknown` (SSL 통신을 함) - **유력한 후보!**

### 3. 접속 및 비밀번호 획득
31790 포트에 `openssl`로 접속해 봅니다.

```bash
bandit16@bandit:~$ openssl s_client -quiet -connect localhost:31790
(현재 비밀번호 cluFn7w7tm7d0LgFAEnvhDBpQh2f3KAn 입력)
Correct!
-----BEGIN RSA PRIVATE KEY-----
MIIEpQIBAAKCAQEAx...
...
-----END RSA PRIVATE KEY-----
```
다음 레벨 접속에 필요한 **RSA Private Key**를 얻었습니다!

### 4. SSH 키 파일 생성 (Private Key)
이번엔 비밀번호 대신 RSA Private Key를 줬습니다. 이걸 복사해서 파일로 저장해야 합니다.
`/tmp`에 가서 파일을 만듭니다.
```bash
# /tmp/sshkey17 파일 생성 후 내용 붙여넣기
nano /tmp/sshkey17 
# (붙여넣기 후 Ctrl+O, Enter, Ctrl+X)
```

#### 5. 권한 설정 및 접속
SSH 키 파일은 **나만 읽을 수 있어야(`600`)** 합니다. 권한이 너무 열려있으면 SSH가 "Unprotected private key file!"이라며 접속을 거부합니다.
```bash
# 중요: 개인키 파일은 권한이 너무 열려있으면 SSH 접속 시 거부당함 (chmod 600 필수)
chmod 600 /tmp/sshkey17
```

다음 레벨 접속 테스트:
```bash
ssh -i /tmp/sshkey17 bandit17@localhost -p 2220
```

---

## 4. 결과

<details markdown="1">
<summary>비밀번호 확인</summary>

(비밀번호 대신 Private Key를 획득했습니다.)
다음 레벨 접속 후 `/etc/bandit_pass/bandit17`을 확인하면 비밀번호를 알 수 있습니다.

```
kIzsmDmbpkh5hp2LAmq2114D2deSR9cW
```

</details>

---

## 5. 배운 점

1. **`nmap`의 강력함**: 단순히 포트가 열렸는지뿐만 아니라, 그 포트 뒤에서 돌고 있는 프로그램이 무엇인지(SSL인지, Echo인지 등)까지 알아낼 수 있습니다.
2. **서비스와 데몬**: 서버에는 항상 특정 포트를 지켜보며(Listening) 연결을 기다리는 프로그램(데몬)이 있습니다.

---

## 6. 보안 관점

- **Reconnaissance (정찰)**: 해커가 공격 대상을 정하면 가장 먼저 하는 것이 `nmap` 스캔입니다. 열린 포트와 서비스 버전을 파악하여 취약점을 찾습니다.
- **불필요한 포트 차단**: 보안을 위해선 사용하지 않는 포트는 방화벽(Firewall)으로 막아두어야 이러한 정찰 행위를 방어할 수 있습니다.

<hr class="short-rule">