---
layout: post
title: "JWT 공부: JSON Web Token 구조와 취약점"
date: 2025-09-17 17:00:00 +0900
categories: [web-technology]
tags: [JWT, Authentication, Web Security, Token, RFC 7519]
description: "JWT의 구조(Header, Payload, Signature) 분석 및 주요 보안 취약점(None Alg, Weak Secret) 실습"
---

## 1. 개요

**JWT (JSON Web Token)**는 당사자 간에 정보를 JSON 객체로 안전하게 전송하기 위한 개방형 표준(RFC 7519)입니다.
주로 웹 애플리케이션의 **인증(Authentication)** 및 **권한 부여(Authorization)**에 사용되며, 서버가 상태를 저장하지 않는(Stateless) REST API 환경에서 널리 쓰입니다.

---

## 2. JWT 구조 분석

JWT는 `.`(점)으로 구분된 세 부분으로 구성됩니다.

![JWT](/assets/images/web-technology/JWT_1.png)

### 2.1. Header (헤더)
토큰의 타입(`JWT`)과 서명 알고리즘(`HS256`, `RS256` 등)을 명시합니다.
```json
{
  "alg": "HS256",
  "typ": "JWT"
}
```

### 2.2. Payload (페이로드)
실제 전달하려는 데이터(Claim)를 담고 있습니다. 사용자 ID, 유효기간(`exp`), 발급자(`iss`) 등이 포함됩니다.
**주의**: 이 부분은 암호화되지 않고 Base64Url로 인코딩만 되어 있으므로, 누구나 내용을 볼 수 있습니다. 비밀번호 같은 민감 정보는 절대 넣으면 안 됩니다.
```json
{
  "sub": "1234567890",
  "name": "John Doe",
  "admin": true
}
```

### 2.3. Signature (서명)
토큰의 무결성을 검증하는 부분입니다. 헤더와 페이로드를 합친 뒤, 서버만 아는 **비밀 키(Secret Key)**로 서명하여 생성합니다.

---

## 3. 주요 보안 취약점 및 공격

### 3.1. None Algorithm 공격
헤더의 `alg` 값을 `none`으로 변경하고 서명 부분을 제거하여 전송했을 때, 서버가 이를 유효한 토큰으로 받아들이는 취약점입니다.
*   **공격 방법**:
    1.  정상 토큰을 획득합니다.
    2.  헤더를 `{"alg": "none", "typ": "JWT"}`로 수정합니다.
    3.  페이로드의 `admin` 값을 `true`로 수정합니다.
    4.  서명 부분을 지우고(마지막 `.`은 남김) 전송합니다.

### 3.2. Weak Secret Key (Brute Force)
HMAC-SHA256 같은 대칭키 알고리즘을 사용할 때, 비밀 키가 짧거나 단순하면(예: `secret`, `1234`) 무차별 대입 공격으로 키를 찾아낼 수 있습니다. 키가 털리면 공격자는 마음대로 관리자 토큰을 생성할 수 있습니다.
*   **도구**: `hashcat`, `John the Ripper` 등을 이용해 서명 값을 크래킹합니다.

---

## 4. 안전한 구현 가이드

1.  **알고리즘 검증 강제**: 서버 측에서 토큰을 검증할 때 `alg` 헤더 값을 그대로 믿지 말고, 서버가 허용하는 알고리즘(예: `HS256`)인지 반드시 확인해야 합니다. 특히 `none` 알고리즘은 무조건 차단해야 합니다.
2.  **강력한 비밀 키 사용**: 무차별 대입이 불가능하도록 충분히 길고 복잡한 비밀 키를 사용해야 합니다.
3.  **유효기간(Expiration) 설정**: 탈취된 토큰의 피해를 최소화하기 위해 `exp` 클레임을 사용하여 유효기간을 짧게 설정하고, Refresh Token을 함께 운용합니다.
4.  **민감 정보 제외**: 페이로드에는 사용자 식별자(ID) 정도만 포함하고, 개인정보나 비밀번호는 포함하지 않습니다.

<hr class="short-rule">